{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prism.Container.Extensions \u00b6 The Prism Container Extensions provide various additional extensions making the Prism Container easier to use with IServiceCollection/IServiceProvider and in scenarios where you may require a Singleton container that may need to be initialized from Platform specific code prior to PrismApplication being created. Note that both the Prism.Container.Extensions and Prism.DryIoc.Extensions are platform agnostic meaning you can use them on WPF or Xamarin Forms. Support \u00b6 This project is maintained by Dan Siegel. If this project or others maintained by Dan have helped you please help support the project by sponsoring Dan on GitHub! Why use the Container Extensions? \u00b6 While the Container abstractions provided by IContainerRegistry will give you what you need at least 95% of the time, there are still a number of times that you need to be able to do some more advanced registrations for your services. While adding these additional methods may confuse the average developer who is still struggling to understand \"What is a Transient, what is a Singleton, when do I use each?\". The extensions give you exactly what you need in order to write extremely loosely coupled code that can be reused from one project to another regardless of whether you are developing for Prism for WPF, Prism for Xamarin.Forms or just doing your own thing with Prism.Core. NuGet \u00b6 Package NuGet MyGet Prism.Container.Extensions Prism.Forms.Extended Prism.DryIoc.Extensions Prism.Microsoft.DependencyInjection.Extensions Prism.Unity.Extensions Shiny.Prism CI NuGet Feed \u00b6 Want to consume the CI packages? You can add this as a NuGet.config in your project root and Visual Studio will automatically pick up the configuration to provide packages from the CI Feed. Note that packages from this feed have passed all of the tests, but may have code that is still unstable. <configuration> <packageSources> <clear /> <add key= \"PrismPlugins-MyGet\" value= \"https://www.myget.org/F/prism-plugins/api/v3/index.json\" /> <add key= \"NuGet.org\" value= \"https://api.nuget.org/v3/index.json\" /> </packageSources> </configuration>","title":"Getting Started"},{"location":"#prismcontainerextensions","text":"The Prism Container Extensions provide various additional extensions making the Prism Container easier to use with IServiceCollection/IServiceProvider and in scenarios where you may require a Singleton container that may need to be initialized from Platform specific code prior to PrismApplication being created. Note that both the Prism.Container.Extensions and Prism.DryIoc.Extensions are platform agnostic meaning you can use them on WPF or Xamarin Forms.","title":"Prism.Container.Extensions"},{"location":"#support","text":"This project is maintained by Dan Siegel. If this project or others maintained by Dan have helped you please help support the project by sponsoring Dan on GitHub!","title":"Support"},{"location":"#why-use-the-container-extensions","text":"While the Container abstractions provided by IContainerRegistry will give you what you need at least 95% of the time, there are still a number of times that you need to be able to do some more advanced registrations for your services. While adding these additional methods may confuse the average developer who is still struggling to understand \"What is a Transient, what is a Singleton, when do I use each?\". The extensions give you exactly what you need in order to write extremely loosely coupled code that can be reused from one project to another regardless of whether you are developing for Prism for WPF, Prism for Xamarin.Forms or just doing your own thing with Prism.Core.","title":"Why use the Container Extensions?"},{"location":"#nuget","text":"Package NuGet MyGet Prism.Container.Extensions Prism.Forms.Extended Prism.DryIoc.Extensions Prism.Microsoft.DependencyInjection.Extensions Prism.Unity.Extensions Shiny.Prism","title":"NuGet"},{"location":"#ci-nuget-feed","text":"Want to consume the CI packages? You can add this as a NuGet.config in your project root and Visual Studio will automatically pick up the configuration to provide packages from the CI Feed. Note that packages from this feed have passed all of the tests, but may have code that is still unstable. <configuration> <packageSources> <clear /> <add key= \"PrismPlugins-MyGet\" value= \"https://www.myget.org/F/prism-plugins/api/v3/index.json\" /> <add key= \"NuGet.org\" value= \"https://api.nuget.org/v3/index.json\" /> </packageSources> </configuration>","title":"CI NuGet Feed"},{"location":"registerdelegates/","text":"Delegate Registration \u00b6 Sometimes you really need a bit more power behind constructing a service. For these times you may find yourself in one of the following scenarios: You just need to perform some Action like: public static IBackendService CreateBackendService () { return new BackendService { Uri = Constants . BackendUri }; } You need to resolve something to do a more complex look up and properly construct your type: public static IBackendService CreateBackendService ( IContainerProvider containerProvider ) { var options = containerProvider . Resolve < IOptions >(); return containerProvider . Resolve < IBackendService >(( typeof ( Uri ), options . BackendUri )); } Note This supports both Delegates with IContainerProvider and IServiceProvider Regardless of which way you need to resolve service the Delegate Registration extensions really help out for those scenarios where you can't just simply pass a raw implementing type. protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterDelegate < IFoo >( FooFactory ); containerRegistry . RegisterDelegate < IBar >( BarFactory ); } private static IFoo FooFactory () => new Foo (); private static IBar BarFactory ( IContainerProvider container ) { var options = container . Resolve < IOptions >(); return new Bar { HasCode = options . HasCode }; } private static IBar BarFactory ( IServiceProvider serviceProvider ) { var options = serviceProvider . GetService < IOptions >(); return new Bar { HasCode = options . HasCode }; }","title":"Delegate Registration"},{"location":"registerdelegates/#delegate-registration","text":"Sometimes you really need a bit more power behind constructing a service. For these times you may find yourself in one of the following scenarios: You just need to perform some Action like: public static IBackendService CreateBackendService () { return new BackendService { Uri = Constants . BackendUri }; } You need to resolve something to do a more complex look up and properly construct your type: public static IBackendService CreateBackendService ( IContainerProvider containerProvider ) { var options = containerProvider . Resolve < IOptions >(); return containerProvider . Resolve < IBackendService >(( typeof ( Uri ), options . BackendUri )); } Note This supports both Delegates with IContainerProvider and IServiceProvider Regardless of which way you need to resolve service the Delegate Registration extensions really help out for those scenarios where you can't just simply pass a raw implementing type. protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterDelegate < IFoo >( FooFactory ); containerRegistry . RegisterDelegate < IBar >( BarFactory ); } private static IFoo FooFactory () => new Foo (); private static IBar BarFactory ( IContainerProvider container ) { var options = container . Resolve < IOptions >(); return new Bar { HasCode = options . HasCode }; } private static IBar BarFactory ( IServiceProvider serviceProvider ) { var options = serviceProvider . GetService < IOptions >(); return new Bar { HasCode = options . HasCode }; }","title":"Delegate Registration"},{"location":"registermany/","text":"RegisterMany \u00b6 One of the very powerful new methods provided by the Container Extensions is the RegisterMany and RegisterManySingleton method. This really can help you reduce how much boilerplate code you need to write and provide some advanced scenarios. So what is it? public interface IFoo { void DoFoo (); } public interface IBar { void DoBar (); } To start let's assume that you have 2 interfaces like the ones above IFoo and IBar . Now let's assume that you have a single implementing type like: public class FooBar : IFoo , IBar { public void DoFoo () { Console . WriteLine ( \"Doing foo\" ); } public void DoBar () { Console . WriteLine ( \"Doing Bar\" ); } } Without the Container Extensions you might have a transient registration like: containerRegistry . Register < IFoo , FooBar >(); containerRegistry . Register < IBar , FooBar >(); While this may not be such a big deal, it suddenly starts making more sense when we expect the use of a singleton. The issue here is that if we were to do something similar to this to register a Singleton traditionally like: containerRegistry . RegisterSingleton < IFoo , FooBar >(); containerRegistry . RegisterSingleton < IBar , FooBar >(); We are under the impression that we have a singleton here. The issue of course is that if you check for equality like: if ( Container . Resolve < IFoo >() == Container . Resolve < IBar >()) { Console . WriteLine ( \"Foo and Bar are the same instance\" ); } else { Console . WriteLine ( \"Foo and Bar are difference instances\" ); } We might expect that the first case would evaluate to true that Foo and Bar are the same instance, but in reality they are two different instances. The issue isn't that we somehow didn't register them as a singleton because if you resolve IFoo twice and do the same equality check it will actually evaluate to true because they would be the same instance. However, Foo and Bar are different instances because they were registered separately. This is where RegisterManySingleton really shines. If we were to update our registration like: // Implicitly registers any implemented interfaces containerRegistry . RegisterManySingleton < FooBar >(); // Explicitly registers implemented interfaces containerRegistry . RegisterManySingleton < FooBar >( typeof ( IFoo ), typeof ( IBar )) We can now perform the same equality check above only this time IFoo and IBar would equal one another because they would both have been resolved from the same instance of the FooBar implementation.","title":"RegisterMany"},{"location":"registermany/#registermany","text":"One of the very powerful new methods provided by the Container Extensions is the RegisterMany and RegisterManySingleton method. This really can help you reduce how much boilerplate code you need to write and provide some advanced scenarios. So what is it? public interface IFoo { void DoFoo (); } public interface IBar { void DoBar (); } To start let's assume that you have 2 interfaces like the ones above IFoo and IBar . Now let's assume that you have a single implementing type like: public class FooBar : IFoo , IBar { public void DoFoo () { Console . WriteLine ( \"Doing foo\" ); } public void DoBar () { Console . WriteLine ( \"Doing Bar\" ); } } Without the Container Extensions you might have a transient registration like: containerRegistry . Register < IFoo , FooBar >(); containerRegistry . Register < IBar , FooBar >(); While this may not be such a big deal, it suddenly starts making more sense when we expect the use of a singleton. The issue here is that if we were to do something similar to this to register a Singleton traditionally like: containerRegistry . RegisterSingleton < IFoo , FooBar >(); containerRegistry . RegisterSingleton < IBar , FooBar >(); We are under the impression that we have a singleton here. The issue of course is that if you check for equality like: if ( Container . Resolve < IFoo >() == Container . Resolve < IBar >()) { Console . WriteLine ( \"Foo and Bar are the same instance\" ); } else { Console . WriteLine ( \"Foo and Bar are difference instances\" ); } We might expect that the first case would evaluate to true that Foo and Bar are the same instance, but in reality they are two different instances. The issue isn't that we somehow didn't register them as a singleton because if you resolve IFoo twice and do the same equality check it will actually evaluate to true because they would be the same instance. However, Foo and Bar are different instances because they were registered separately. This is where RegisterManySingleton really shines. If we were to update our registration like: // Implicitly registers any implemented interfaces containerRegistry . RegisterManySingleton < FooBar >(); // Explicitly registers implemented interfaces containerRegistry . RegisterManySingleton < FooBar >( typeof ( IFoo ), typeof ( IBar )) We can now perform the same equality check above only this time IFoo and IBar would equal one another because they would both have been resolved from the same instance of the FooBar implementation.","title":"RegisterMany"},{"location":"scoping/","text":"Scoping \u00b6 TODO","title":"Scoped Services"},{"location":"scoping/#scoping","text":"TODO","title":"Scoping"},{"location":"containers/","text":"Initialization \u00b6 The PrismContainerExtension can be initialized automatically and accessed by simply calling PrismContainerExtension.Current . You can also create a new container with any of the following methods: // Use Default Prism configuration PrismContainerExtension . Create (); // Use custom Container with custom rules PrismContainerExtension . Create ( new Container ()); NOTE That by default the container extension will ensure that the underlying container is properly configured to work with Prism Applications. Modifying PrismApplication \u00b6 When using the extended container extension you simply need to add the following to your PrismApplication to ensure that it uses the same instance that may have been created prior to the initialization of PrismApplication. protected override IContainerExtension CreateContainerExtension () => PrismContainerExtension . Current ; NOTE: This section ONLY applies to applications that are based on the Official packages from Prism. If you're using an Extended PrismApplication from this repo you do not need to modify the PrismApplication.","title":"Basics"},{"location":"containers/#initialization","text":"The PrismContainerExtension can be initialized automatically and accessed by simply calling PrismContainerExtension.Current . You can also create a new container with any of the following methods: // Use Default Prism configuration PrismContainerExtension . Create (); // Use custom Container with custom rules PrismContainerExtension . Create ( new Container ()); NOTE That by default the container extension will ensure that the underlying container is properly configured to work with Prism Applications.","title":"Initialization"},{"location":"containers/#modifying-prismapplication","text":"When using the extended container extension you simply need to add the following to your PrismApplication to ensure that it uses the same instance that may have been created prior to the initialization of PrismApplication. protected override IContainerExtension CreateContainerExtension () => PrismContainerExtension . Current ; NOTE: This section ONLY applies to applications that are based on the Official packages from Prism. If you're using an Extended PrismApplication from this repo you do not need to modify the PrismApplication.","title":"Modifying PrismApplication"},{"location":"containers/dryioc/","text":"","title":"DryIoc"},{"location":"containers/microsoft-extensions-dependencyinjection/","text":"Microsoft.Extensions.DependencyInjection \u00b6 Warning!!! Support for this container is proof of concept. This may still have a number of bugs. It is not advised to use this for production code at this time. For a number of developers, the Service Provider in Microsoft.Extensions.DependencyInjection is a great lightweight D.I. container. Traditionally this has never been seriously considered for Prism support since Prism has a hard requirement on named services in order to resolve your Views. Prism also has a bit of a requirement that it be able to resolve a service that was never registered. What makes this different? \u00b6 The requirement for named services never went away, nor did the requirement that we can resolve types like your ViewModels which are never directly registered. This package provides some additions though that allow us to track mapping between keys and types as well as to resolve concrete types even if they haven't been registered. With these two enhancements built on top of Microsoft's DI Extensions we are able to support Prism with the container. Using the Container \u00b6 This container is most likely to be used any time that you're using Shiny, but this can be used completely independently from Shiny or even Prism.","title":"Microsoft D.I. Extensions"},{"location":"containers/microsoft-extensions-dependencyinjection/#microsoftextensionsdependencyinjection","text":"Warning!!! Support for this container is proof of concept. This may still have a number of bugs. It is not advised to use this for production code at this time. For a number of developers, the Service Provider in Microsoft.Extensions.DependencyInjection is a great lightweight D.I. container. Traditionally this has never been seriously considered for Prism support since Prism has a hard requirement on named services in order to resolve your Views. Prism also has a bit of a requirement that it be able to resolve a service that was never registered.","title":"Microsoft.Extensions.DependencyInjection"},{"location":"containers/microsoft-extensions-dependencyinjection/#what-makes-this-different","text":"The requirement for named services never went away, nor did the requirement that we can resolve types like your ViewModels which are never directly registered. This package provides some additions though that allow us to track mapping between keys and types as well as to resolve concrete types even if they haven't been registered. With these two enhancements built on top of Microsoft's DI Extensions we are able to support Prism with the container.","title":"What makes this different?"},{"location":"containers/microsoft-extensions-dependencyinjection/#using-the-container","text":"This container is most likely to be used any time that you're using Shiny, but this can be used completely independently from Shiny or even Prism.","title":"Using the Container"},{"location":"containers/unity/","text":"","title":"Unity"},{"location":"forms/","text":"Using the Prism.Forms.Extended \u00b6 The Prism.Forms.Extended package is designed to make it even easier for you to integrate these fantastic packages. As you'll see using it is identical in every way to creating a typical Prism Application. The only difference is that you are installing the Prism.Forms.Extended package instead of Prism.Forms, Prism.DryIoc.Forms or Prism.Unity.Forms. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > </prism:PrismApplication> public partial class App { protected override void OnInitialized () { InitializeComponent (); NavigationService . NavigateAsync ( \"MainPage\" ); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // Register your services like normal containerRegistry . RegisterForNavigation < MainPage >(); } } Critical Notice The Prism Application in Prism.Forms.Extended requires the use of a container implementation from the Prism.Container.Extensions project. It will automatically wire in any reference without any changes to code. You simple need to ensure that Prism.DryIoc.Extensions, Prism.Microsoft.DependencyInjection.Extensions, or Prism.Unity.Extensions is installed. Why use Prism.Forms.Extended \u00b6 The extended PrismApplication is cross compiled for Xamarin.iOS and Xamarin.Android and provides several out of the box improvements over the normal PrismApplication. It includes the ILogger from Prism.Plugin.Logging By default the Console Logger is registered and is available. It has pre-wired support for logging XAML errors and other issues directly from Xamarin.Forms (It will use your ILogger to log things like Bindings that cannot be resolved) Becase it is cross compiled, it has global Exception Handling built in for: AndroidEnvironment ObjectiveC.Runtime AppDomain TaskScheduler It provides you all of the container extensions found here that help make advanced registration scenarios much easier. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > <prism:PrismApplication.ModuleCatalog> <prism:ModuleCatalog> <prism:ModuleInfo /> </prism.ModuleCatalog> </prism:PrismApplication.ModuleCatalog> </prism:PrismApplication>","title":"Intro"},{"location":"forms/#using-the-prismformsextended","text":"The Prism.Forms.Extended package is designed to make it even easier for you to integrate these fantastic packages. As you'll see using it is identical in every way to creating a typical Prism Application. The only difference is that you are installing the Prism.Forms.Extended package instead of Prism.Forms, Prism.DryIoc.Forms or Prism.Unity.Forms. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > </prism:PrismApplication> public partial class App { protected override void OnInitialized () { InitializeComponent (); NavigationService . NavigateAsync ( \"MainPage\" ); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // Register your services like normal containerRegistry . RegisterForNavigation < MainPage >(); } } Critical Notice The Prism Application in Prism.Forms.Extended requires the use of a container implementation from the Prism.Container.Extensions project. It will automatically wire in any reference without any changes to code. You simple need to ensure that Prism.DryIoc.Extensions, Prism.Microsoft.DependencyInjection.Extensions, or Prism.Unity.Extensions is installed.","title":"Using the Prism.Forms.Extended"},{"location":"forms/#why-use-prismformsextended","text":"The extended PrismApplication is cross compiled for Xamarin.iOS and Xamarin.Android and provides several out of the box improvements over the normal PrismApplication. It includes the ILogger from Prism.Plugin.Logging By default the Console Logger is registered and is available. It has pre-wired support for logging XAML errors and other issues directly from Xamarin.Forms (It will use your ILogger to log things like Bindings that cannot be resolved) Becase it is cross compiled, it has global Exception Handling built in for: AndroidEnvironment ObjectiveC.Runtime AppDomain TaskScheduler It provides you all of the container extensions found here that help make advanced registration scenarios much easier. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > <prism:PrismApplication.ModuleCatalog> <prism:ModuleCatalog> <prism:ModuleInfo /> </prism.ModuleCatalog> </prism:PrismApplication.ModuleCatalog> </prism:PrismApplication>","title":"Why use Prism.Forms.Extended"},{"location":"forms/executionawarecommand/","text":"Have you ever looked at ReactiveCommand and wished that the DelegateCommand could be more like that, while also wishing the ReactiveCommand could be more like the DelegateCommand. This was the reason that yet another command was introduced in the Prism.Forms.Extended package. The ExecutionAwareCommand solves a few problems. Fluent API Support for Async Delegates Support for ObservesProperty Support for ObservesCanExecute Support for adding Exception Handlers directly on the Command Support for adding a IsExecuting Changed delegate Support for opting in or out of InvalidCastExceptions Using the ExecutionAwareCommand \u00b6 public class ViewAViewModel : BindableBase { public ViewAViewModel () { FooCommand = ExecutionAwareCommand . FromAction ( DoFoo ) . OnIsExecutingChanged ( b => IsBusy = b ) . Catch ( e => { // equivalent to catch(Exception e) }) . Catch < NullReferenceException >( e => { // e is strongly typed as NullReferenceException }); } private bool _isBusy ; public bool IsBusy { get => _isBusy ; set => SetProperty ( ref _isBusy , value ); } public ICommand FooCommand { get ; } private void DoFoo () { // Do Foo } } Note Both ExecutionAwareCommand and ExecutionAwareCommand<T> only support creation from the factory methods: FromAction FromTask","title":"ExecutionAwareCommand"},{"location":"forms/executionawarecommand/#using-the-executionawarecommand","text":"public class ViewAViewModel : BindableBase { public ViewAViewModel () { FooCommand = ExecutionAwareCommand . FromAction ( DoFoo ) . OnIsExecutingChanged ( b => IsBusy = b ) . Catch ( e => { // equivalent to catch(Exception e) }) . Catch < NullReferenceException >( e => { // e is strongly typed as NullReferenceException }); } private bool _isBusy ; public bool IsBusy { get => _isBusy ; set => SetProperty ( ref _isBusy , value ); } public ICommand FooCommand { get ; } private void DoFoo () { // Do Foo } } Note Both ExecutionAwareCommand and ExecutionAwareCommand<T> only support creation from the factory methods: FromAction FromTask","title":"Using the ExecutionAwareCommand"},{"location":"forms/fluent-navigation/","text":"The use of fluent API's and declartive syntax is gaining popularity. There is a lot to be said for this as it becomes very clear about what we might expect. Using the Fluent API \u00b6 navService . Navigate ( \"ViewA\" ) . WithParameter ( \"message\" , \"Hello World\" ) . Catch ( e => { // Equivalent to catch(Exception e) }) . Catch < ArgumentNullException >( e => { // Equivalent to catch(ArgumentNullException e) }) . ExecuteAsync (); Note When using the Fluent API, ExecuteAsync returns a Task<bool> and not a Task<INavigationResult> . It is important that if you want to do something with an exception returned by the INavigationResult in the underlying API, you must provide a Catch to handle it in the Fluent API.","title":"Fluent Navigation"},{"location":"forms/fluent-navigation/#using-the-fluent-api","text":"navService . Navigate ( \"ViewA\" ) . WithParameter ( \"message\" , \"Hello World\" ) . Catch ( e => { // Equivalent to catch(Exception e) }) . Catch < ArgumentNullException >( e => { // Equivalent to catch(ArgumentNullException e) }) . ExecuteAsync (); Note When using the Fluent API, ExecuteAsync returns a Task<bool> and not a Task<INavigationResult> . It is important that if you want to do something with an exception returned by the INavigationResult in the underlying API, you must provide a Catch to handle it in the Fluent API.","title":"Using the Fluent API"},{"location":"forms/navigationerrors/","text":"Errors happen when navigating. Using the PrismApplication in Prism.Forms.Extended allows you to automatically and globally handle these errors. Overriding the Default Behavior \u00b6 protected override void OnNavigationError ( INavigationError navigationError ) { // Do something with the INavigationError } Default Behavior \u00b6 Writes to the Console that there was a Navigation Error Resolves the ILogger, and Reports the Error with the following additional properties Serializes the NavigationParameters to a JSON string Adds the Navigation Uri","title":"Global Navigation Errors"},{"location":"forms/navigationerrors/#overriding-the-default-behavior","text":"protected override void OnNavigationError ( INavigationError navigationError ) { // Do something with the INavigationError }","title":"Overriding the Default Behavior"},{"location":"forms/navigationerrors/#default-behavior","text":"Writes to the Console that there was a Navigation Error Resolves the ILogger, and Reports the Error with the following additional properties Serializes the NavigationParameters to a JSON string Adds the Navigation Uri","title":"Default Behavior"},{"location":"forms/pagebehaviorfactory/","text":"Prism's IPageBehaviorFactory is a great way to apply some custom behaviors on to pages either globally or with a little business logic. The Extended Prism.Forms package uses a custom PageBehaviorFactory. In addition to the normal behaviors that Prism applies to your Pages behind the scenes, the Extended version provides support for the following: Globally adding Platform Specifics on: SetToolbarPlacement on Android TabbedPage Use Safe Area on iOS PreferLargeTitles on iOS A custom behavior that changes the Title of a TabbedPage to always match the actively selected Tab To control these features you simply need to register an implementation of IPageBehaviorFactoryOptions . Note A default instance is provided automatically that enables all of these features. internal class MyPageBehaviorFactoryOptions : IPageBehaviorFactoryOptions { public bool UseBottomTabs => true ; public bool UseSafeArea => true ; public bool UseChildTitle => true ; public bool PreferLargeTitles => true ; }","title":"Page Behavior Factory"},{"location":"shiny/","text":"Working With Shiny \u00b6 Shiny uses the Microsoft.Extensions.DependencyInjection pattern found in ASP.NET Core applications with a Startup class. This in particular is a use case in which you will need to initialize a container prior to Forms.Init being called on the native platform. To work with Shiny you simply need to do something like the following: // Android public class App : Android . App . Application { public override void OnCreate () { AndroidShinyHost . Init ( this , new MyStartup ()); } } // iOS [Register(\"AppDelegate\")] public partial class AppDelegate : FormsApplicationDelegate { public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { // this needs to be loaded before EVERYTHING iOSShinyHost . Init ( new MyStartup ()); Forms . Init (); this . LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } // if you are using jobs, you need this public override void PerformFetch ( UIApplication application , Action < UIBackgroundFetchResult > completionHandler ) => JobManager . OnBackgroundFetch ( completionHandler ); }","title":"Intro"},{"location":"shiny/#working-with-shiny","text":"Shiny uses the Microsoft.Extensions.DependencyInjection pattern found in ASP.NET Core applications with a Startup class. This in particular is a use case in which you will need to initialize a container prior to Forms.Init being called on the native platform. To work with Shiny you simply need to do something like the following: // Android public class App : Android . App . Application { public override void OnCreate () { AndroidShinyHost . Init ( this , new MyStartup ()); } } // iOS [Register(\"AppDelegate\")] public partial class AppDelegate : FormsApplicationDelegate { public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { // this needs to be loaded before EVERYTHING iOSShinyHost . Init ( new MyStartup ()); Forms . Init (); this . LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } // if you are using jobs, you need this public override void PerformFetch ( UIApplication application , Action < UIBackgroundFetchResult > completionHandler ) => JobManager . OnBackgroundFetch ( completionHandler ); }","title":"Working With Shiny"},{"location":"shiny/modularity/","text":"","title":"Modularity"},{"location":"shiny/navigation/","text":"Navigation from Shiny Services \u00b6 While this is generally not a great idea, there could potentially be times in which you need to navigate from a background service. For these times you will need to use the INavigationServiceDelegate. public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { services . UseNavigationDelegate (); } } public class MyJob : IJob { private INavigationServiceDelegate NavigationService { get ; } public MyJob ( INavigationServiceDelegate navigationServiceDelegate ) { NavigationService = navigationServiceDelegate ; } public async Task < bool > Run ( JobInfo jobInfo , CancellationToken cancelToken ) { // Your logic await NavigationService . NavigateAsync ( \"SomePage?useModal=true\" ); } }","title":"Navigation"},{"location":"shiny/navigation/#navigation-from-shiny-services","text":"While this is generally not a great idea, there could potentially be times in which you need to navigate from a background service. For these times you will need to use the INavigationServiceDelegate. public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { services . UseNavigationDelegate (); } } public class MyJob : IJob { private INavigationServiceDelegate NavigationService { get ; } public MyJob ( INavigationServiceDelegate navigationServiceDelegate ) { NavigationService = navigationServiceDelegate ; } public async Task < bool > Run ( JobInfo jobInfo , CancellationToken cancelToken ) { // Your logic await NavigationService . NavigateAsync ( \"SomePage?useModal=true\" ); } }","title":"Navigation from Shiny Services"},{"location":"shiny/startup/","text":"public class PrismStartup : ShinyStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGpsBackground < MyDelegate >(); } public override IServiceProvider CreateServiceProvider ( IServiceCollection services ) { return PrismContainerExtension . Current . CreateServiceProvider ( services ); } } Shiny.Prism \u00b6 With your App using the PrismApplication from Prism.DryIoc.Forms.Extended you now only need to reference the PrismStartup as the base class for your Startup class like: public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGps < MyDelegate >(); } } You can now pass your startup to the ShinyHost at your application's startup and use full Dependency Injection of Shiny's services in your app, full DI of services from Prism's container within services that are resolved by Shiny. NOTE: Shiny uses IServiceProvider which does not support the use of named services.","title":"Startup"},{"location":"shiny/startup/#shinyprism","text":"With your App using the PrismApplication from Prism.DryIoc.Forms.Extended you now only need to reference the PrismStartup as the base class for your Startup class like: public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGps < MyDelegate >(); } } You can now pass your startup to the ShinyHost at your application's startup and use full Dependency Injection of Shiny's services in your app, full DI of services from Prism's container within services that are resolved by Shiny. NOTE: Shiny uses IServiceProvider which does not support the use of named services.","title":"Shiny.Prism"}]}